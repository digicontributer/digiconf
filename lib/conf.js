var base64 = require("base64it");
var crypto = require('crypto');
var dns = require('dns');

/*
* Generates a config file
* @opts {object} Object containing generation options.
* @returns {string}
*/
function generate(opts, cb) {
    const node = [
        '# This config was generated by DigiConf\n',
        '\n',
        '# Place this config in the following path:\n',
    ];

    if(opts.os === 'Windows') {
        node.push('# %UserProfile%\\AppData\\Roaming\\DigiByte\\digibyte.conf\n');
    } else if (opts.os === 'Linux') {
        node.push('# ~/.digibyte/digibyte.conf\n');
    } else if (opts.os === 'Mac OS') {
        node.push('# $HOME/Library/Application Support/DigiByte/digibyte.conf\n');
    }

    node.push(...[
        '\n',
        'server=1\n',
        'listen=1\n',
        'daemon=1\n',
    ]);

    getNodes((err, addresses) => {
        if (err) {
            return cb(err);
        }

        getRpcDetails(opts.user || 'user', (err, rpcDetails) => {
            node.push(`rpcuser=${opts.user || 'user'}\n`);
            node.push(`rpcpassword=${rpcDetails.password}\n`);
            node.push(`rpcauth=${opts.user || 'user'}:${rpcDetails.auth}\n`);
            node.push('rpcport=14022\n');
            node.push('rpcallowip=127.0.0.1\n');

            if(opts.algo) {
                node.push(`algo=${opts.algo.toLowerCase()}\n`);
            } else {
                node.push('algo=scrypt\n');
            }

            if(opts.txindex && opts.txindex !== 'false') {
                node.push('txindex=1\n')
            }

            node.push(`maxconnections=${opts.maxconnections || 8}\n`);
            node.push(...addresses);

            return cb(null, node.join(''));
        });
    });
}

/*
* Gets a list of ipv4 nodes from seed.digibyte.io
* @returns {array}
*/
function getNodes(cb) {
    dns.resolve4('seed.digibyte.io', (err, resp) => {
        if (err) {
            return cb(err);
        }
        var nodes = resp.map(addr => {
            return `addnode=${addr}\n`;
        });

        return cb(null, nodes);
    });
}

/*
* Generates the rpcauth
* @username {string} the username to generate auth for
* @returns {object}
*/
function getRpcDetails(username, cb) {
    
    var salt = crypto.randomBytes(16).toString('hex');
    
    var password = base64.encode(crypto.randomBytes(32), { urlSafe: true });
    var auth = crypto.createHmac('sha256', salt).update(password).digest('hex');
    
    return cb(null, {
        auth: `${salt}${auth}`,
        password
    });
}

module.exports = {
    generate,
    getNodes,
    getRpcDetails
}